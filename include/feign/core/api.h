/**
 * Author:    Zackary Misso
 * Version:   0.2.0
 *
 * Anyone has permission to use the following code as long as proper
 * acknowledgement is provided to the original author(s).
 **/

#pragma once

// eventually, you will be able to create renders by only having to include api.h
// and calling the correct api calls to initialize a scene.

// the format of the api is slightly different than the format of the rest of the
// project. All method names are written in lower case and separate words are
// separated by underscores.

// this api is the main interface between this renderer and whatever application
// or gui attempting to use it. This api is made to be used to set up a scene
// and sets up the parameters and executes renders. If a feature is added to
// this renderer, then it should also be made available here.

#include <feign/common.h>
#include <feign/core/scene.h>
#include <feign/core/shader.h>
#include <feign/core/texture.h>
#include <feign/core/sdf.h>
#include <unordered_map>

FEIGN_BEGIN()

// The end goal is to design all of this so it can be specified by a node graph
// but it also needs to retain speed

class FeignRenderer
{
private:
    FeignRenderer(Imagef* target = nullptr);
    ~FeignRenderer();

    static FeignRenderer* instance;

protected:
    static FeignRenderer* getInstance() { return instance; }

public:

    Transform current_transform;
    SceneNode* scene;
    Imagef* target;

    // TODO: these really should not be public
    // TODO: replace all of the below declarations and functions with macro
    //       autogenerated code
    std::unordered_map<std::string, BSDFNode*> bsdfs;
    std::unordered_map<std::string, CameraNode*> cameras;
    std::unordered_map<std::string, EmitterNode*> emitters;
    std::unordered_map<std::string, MediaNode*> medias;
    std::unordered_map<std::string, IntegratorNode*> integrators;
    std::unordered_map<std::string, SamplerNode*> samplers;
    std::unordered_map<std::string, FilterNode*> filters;
    // std::unordered_map<std::string, MaterialNode*> materials;
    std::unordered_map<std::string, ObjectNode*> objects;
    std::unordered_map<std::string, MeshNode*> meshes;
    std::unordered_map<std::string, GeometryShaderNode*> geom_shaders;
    std::unordered_map<std::string, MaterialShaderNode*> material_shaders;
    std::unordered_map<std::string, TextureNode*> textures;
    std::unordered_map<std::string, DensityFunctionNode*> density_funcs;
    std::unordered_map<std::string, PhaseFunctionNode*> phase_funcs;
    std::unordered_map<std::string, MediumSamplingNode*> medium_samplings;
    std::unordered_map<std::string, TransmittanceEstimatorNode*> trans_ests;
    std::unordered_map<std::string, TransFuncNode*> trans_funcs;

    // TODO: the find methods should really not be public
    BSDFNode*                   find_bsdf(std::string name);
    IntegratorNode*             find_integrator(std::string name);
    CameraNode*                 find_camera(std::string name);
    EmitterNode*                find_emitter(std::string name);
    MediaNode*                  find_media(std::string name);
    SamplerNode*                find_sampler(std::string name);
    FilterNode*                 find_filter(std::string name);
    MaterialNode*               find_material(std::string name);
    ObjectNode*                 find_object(std::string name);
    MeshNode*                   find_mesh(std::string name);
    GeometryShaderNode*         find_geometry_shader(std::string name);
    MaterialShaderNode*         find_material_shader(std::string name);
    TextureNode*                find_texture(std::string name);
    DensityFunctionNode*        find_density_func(std::string name);
    PhaseFunctionNode*          find_phase_func(std::string name);
    MediumSamplingNode*         find_medium_sampling(std::string name);
    TransmittanceEstimatorNode* find_transmittance_estimator(std::string name);
    TransFuncNode*              find_transmittance_func(std::string name);

    // if image_target is specified, the renderer will render to the
    // image, otherwise it will output to a file
    static void initialize(Imagef* image_target = nullptr);

    static void clean_up();

    static void fr_accel(std::string name,
                         std::string type,
                         void* accel_properties);

    static void fr_scene(std::string name,
                         std::string integrator_node,
                         std::string sampler_node,
                         std::string camera_node,
                         std::string medium_node,
                         bool sdf_mode = false);

    static void fr_integrator(std::string name,
                              std::string type,
                              std::string filter,
                              void* integrator_data);

    static void fr_sampler(std::string name,
                           std::string type,
                           void* sampler_data);

    static void fr_camera(std::string name,
                          std::string type,
                          void* camera_data);

    static void fr_object(std::string name,
                          std::string mesh,
                          std::string material_shader,
                          std::string emitter = "null",
                          std::string medium = "null",
                          int index = -1); // what is this index parameter again

    static void fr_mesh(std::string name,
                        std::string type,
                        void* mesh_data);

    // TODO: should this be separated into the different shaders?
    static void fr_shader(std::string name,
                          std::string type,
                          void* shader_data);

//////////////////////////////////// MEDIA ////////////////////////////////////
    static void fr_media(std::string name,
                         std::string type,
                         void* shader_data);

    static void fr_medium_density(std::string name,
                                  std::string type,
                                  void* density_data);

    static void fr_medium_phase(std::string name,
                                std::string type,
                                void* phase_data);

    static void fr_medium_sampling(std::string name,
                                   std::string type,
                                   void* sample_data);

    static void fr_medium_transmittance(std::string name,
                                        std::string type,
                                        void* trans_est_data);

    static void fr_medium_transmittance_func(std::string name,
                                             std::string type,
                                             void* trans_func_data);
//////////////////////////////////// MEDIA ////////////////////////////////////

    static void fr_emitter(std::string name,
                           std::string type,
                           void* emitter_data);

    // static void fr_material(std::string name,
    //                         std::string type,
    //                         void* material_data);

    static void fr_bsdf(std::string name,
                        std::string type,
                        void* bsdf_data);

    static void fr_texture(std::string name,
                           std::string type,
                           void* texture_data);

    static void fr_clear_transform();
    static void fr_scale(float sx, float sy, float sz);
    static void fr_translate(float tx, float ty, float tz);
    static void fr_rotate(float angle, float x, float y, float z);

    static void flush_renders();
};

FEIGN_END()
